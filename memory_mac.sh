#!/bin/sh
# Mnemo memory installer (macOS / POSIX shell)
# Zero extra requirements on macOS: uses /bin/sh + standard Unix tools.
#
# Usage (from repo root, macOS Terminal):
#   sh ./memory_mac.sh
#   sh ./memory_mac.sh --project-name "MyProject"
#   sh ./memory_mac.sh --force
#
# This creates:
#   .cursor/memory/*, .cursor/rules/*, scripts/memory/*, .githooks/pre-commit

set -eu

REPO_ROOT="$(pwd)"
PROJECT_NAME=""
FORCE="0"

while [ $# -gt 0 ]; do
  case "$1" in
    --repo-root)
      REPO_ROOT="$2"; shift 2;;
    --project-name)
      PROJECT_NAME="$2"; shift 2;;
    --force)
      FORCE="1"; shift 1;;
    -h|--help)
      echo "Usage: sh ./memory_mac.sh [--repo-root PATH] [--project-name NAME] [--force]"
      exit 0;;
    *)
      echo "Unknown arg: $1" >&2
      exit 2;;
  esac
done

if [ -z "$PROJECT_NAME" ]; then
  PROJECT_NAME="$(basename "$REPO_ROOT")"
fi

MONTH="$(date +%Y-%m)"
TODAY="$(date +%Y-%m-%d)"

CURSOR_DIR="$REPO_ROOT/.cursor"
MEMORY_DIR="$CURSOR_DIR/memory"
RULES_DIR="$CURSOR_DIR/rules"
JOURNAL_DIR="$MEMORY_DIR/journal"
DIGESTS_DIR="$MEMORY_DIR/digests"
ADR_DIR="$MEMORY_DIR/adr"
LESSONS_DIR="$MEMORY_DIR/lessons"
TEMPLATES_DIR="$MEMORY_DIR/templates"
SCRIPTS_DIR="$REPO_ROOT/scripts"
MEM_SCRIPTS_DIR="$SCRIPTS_DIR/memory"
GITHOOKS_DIR="$REPO_ROOT/.githooks"

mkdir -p "$CURSOR_DIR" "$MEMORY_DIR" "$RULES_DIR" "$JOURNAL_DIR" "$DIGESTS_DIR" "$ADR_DIR" "$LESSONS_DIR" "$TEMPLATES_DIR" "$SCRIPTS_DIR" "$MEM_SCRIPTS_DIR" "$GITHOOKS_DIR"

write_file() {
  # write_file <path> <stdin>
  path="$1"
  if [ -f "$path" ] && [ "$FORCE" != "1" ]; then
    printf '%s\n' "SKIP (exists): $path"
    return 0
  fi
  tmp="${path}.tmp.$$"
  cat > "$tmp"
  mv "$tmp" "$path"
  printf '%s\n' "WROTE: $path"
}

# -------------------------
# Memory files
# -------------------------

write_file "$MEMORY_DIR/index.md" <<'EOF'
# Memory Index

Entry point for repo memory.

## Read order (token-safe)

ALWAYS READ (in order):
1) `hot-rules.md` (tiny invariants, <20 lines)
2) `active-context.md` (this session only)
3) `memo.md` (long-term current truth + ownership)

SEARCH FIRST, THEN OPEN ONLY WHAT MATCHES:
4) `lessons/index.md` -> find lesson ID(s)
5) `lessons/L-XXX-*.md` -> open only specific lesson(s)
6) `digests/YYYY-MM.digest.md` -> before raw journal
7) `journal/YYYY-MM.md` -> only for archaeology

## Maintenance commands

Shell helper scripts (macOS-friendly):
- Add lesson: `scripts/memory/add-lesson.sh --title "..." --tags "..." --rule "..."`
- Add journal: `scripts/memory/add-journal-entry.sh --tags "..." --title "..."`
- Rebuild indexes: `scripts/memory/rebuild-memory-index.sh`
- Lint: `scripts/memory/lint-memory.sh`
- Query: `scripts/memory/query-memory.sh --query "..."`
- Clear session: `scripts/memory/clear-active.sh`
EOF

write_file "$MEMORY_DIR/hot-rules.md" <<'EOF'
# Hot Rules (MUST READ)

Keep this file under ~20 lines. If it grows, move content into memo or lessons.

## Authority Order (highest to lowest)
1) Lessons override EVERYTHING (including active-context)
2) `active-context.md` overrides memo/journal (but NOT lessons)
3) `memo.md` is long-term project truth
4) journal is history

## Retrieval Rules
5) Do NOT scan raw journals. Use indexes/digests first.
6) Reuse existing patterns. Check memo.md ownership before creating new systems.
7) When done: clear active-context.md, add journal entry if significant.
EOF

write_file "$MEMORY_DIR/active-context.md" <<'EOF'
# Active Context (Session Scratchpad)

Priority: this overrides older journal history *for this session only*.

CLEAR this file when the task is done:
- Run `scripts/memory/clear-active.sh`

## Current Goal
-

## Files in Focus
-

## Findings / Decisions
-

## Temporary Constraints
-

## Blockers
-
EOF

write_file "$MEMORY_DIR/memo.md" <<EOF
# Project Memo - $PROJECT_NAME

Last updated: $TODAY

## Ownership / Modules
- TODO

## Invariants
- TODO

## Build / Run
- TODO

## Integration Points
- TODO
EOF

write_file "$LESSONS_DIR/README.md" <<'EOF'
# Lessons

Lessons are atomic “rules learned the hard way”.

Rules:
- One lesson per file: `L-XXX-title.md`
- Must include YAML frontmatter at the top (`---` … `---`)
- Keep lessons high-signal and reusable
EOF

write_file "$LESSONS_DIR/index.md" <<'EOF'
# Lessons Index (generated)

Generated by `scripts/memory/rebuild-memory-index.sh`.

Format: ID | [Tags] | AppliesTo | Rule | File

(No lessons yet.)
EOF

write_file "$JOURNAL_DIR/README.md" <<'EOF'
# Journal

Monthly file: `YYYY-MM.md`

Rules:
- Each date appears ONCE per file: `## YYYY-MM-DD`
- Put multiple entries under that header as bullets.
- Keep it high-signal: what changed, why, key files.
EOF

write_file "$JOURNAL_DIR/$MONTH.md" <<EOF
# Development Journal - $PROJECT_NAME ($MONTH)

## $TODAY

- [Process] Initialized memory system (Mnemo shell installer)
  - Why: token-safe AI memory + indexed retrieval + portable hooks
  - Key files:
    - \`.cursor/memory/*\`
    - \`.cursor/rules/00-memory-system.mdc\`
    - \`scripts/memory/*\`
EOF

write_file "$DIGESTS_DIR/README.md" <<'EOF'
# Digests

Generated summaries of journal months.
AI should read digests before raw journal.
EOF

write_file "$ADR_DIR/README.md" <<'EOF'
# ADRs

Architecture Decision Records: why we did it this way.

Naming:
- `ADR-001-short-title.md`
EOF

write_file "$MEMORY_DIR/tag-vocabulary.md" <<'EOF'
# Tag Vocabulary (fixed set)

Use a small vocabulary so retrieval stays reliable.

- [UI] - UI behavior, rendering, interaction
- [Layout] - layout groups, anchors, sizing, rects
- [Input] - mouse/keyboard/controller input rules
- [Data] - parsing, payloads, formats, state sync
- [Server] - server-side logic and lifecycle
- [Init] - initialization / load order / startup
- [Build] - compilation, project files
- [CI] - automation, pipelines
- [Release] - packaging, artifacts, uploads
- [Compat] - runtime constraints, environment quirks
- [Integration] - plugins, external systems
- [Docs] - documentation and changelog work
- [Architecture] - module boundaries, refactors, ownership
- [DX] - developer experience, tooling, maintainability
- [Reliability] - crash prevention, guardrails, self-healing
- [Process] - workflow, memory system, tooling changes

# Common "type" tags (templates/examples)
- [Fix] - bug fixes, regressions, patches
- [Feature] - new behavior/capability
- [Refactor] - restructuring without behavior changes
EOF

write_file "$MEMORY_DIR/regression-checklist.md" <<'EOF'
# Regression Checklist

Run only what is relevant.

## Build
- [ ] Build / run relevant commands
- [ ] No new warnings (or documented)

## Runtime (if applicable)
- [ ] Core UI renders
- [ ] Core interactions work
- [ ] No obvious errors/log spam

## Docs (if applicable)
- [ ] Journal updated
- [ ] Memo updated (if truth changed)
- [ ] Lesson added (if pitfall discovered)
EOF

write_file "$TEMPLATES_DIR/lesson.template.md" <<'EOF'
---
id: L-XXX
title: Short descriptive title
status: Active
tags: [UI, Reliability]
introduced: YYYY-MM-DD
applies_to:
  - path/or/glob/**
triggers:
  - error keyword
rule: One sentence. Imperative. Testable.
supersedes: ""
---

# L-XXX - Short descriptive title

## Symptom
TODO

## Root cause
TODO

## Wrong approach (DO NOT REPEAT)
- TODO

## Correct approach
- TODO
EOF

write_file "$TEMPLATES_DIR/journal-entry.template.md" <<'EOF'
# Journal Entry Template (paste under an existing date header)

- [Area][Type] Title
  - Why: ...
  - Key files:
    - `path/to/file`
  - Verification: Build PASS/FAIL/NOT RUN; Runtime PASS/FAIL/NOT RUN
EOF

write_file "$TEMPLATES_DIR/adr.template.md" <<'EOF'
# ADR-XXX - Title

Date: YYYY-MM-DD
Status: Proposed | Accepted | Deprecated

## Context
TODO

## Decision
TODO

## Consequences
TODO
EOF

# -------------------------
# Cursor rule (Cursor will pick this up; other agents can still read .cursor/memory)
# -------------------------

write_file "$RULES_DIR/00-memory-system.mdc" <<'EOF'
---
description: Mnemo Memory System - Authority + Atomic Retrieval + Token Safety
globs:
  - "**/*"
alwaysApply: true
---

# Memory System (MANDATORY)

## Authority Order (highest to lowest)
1) Lessons override EVERYTHING (including active-context)
2) `active-context.md` overrides memo/journal (but NOT lessons)
3) `memo.md` is long-term project truth
4) Journal is history

## Token-Safe Retrieval

ALWAYS READ (in order):
1. `.cursor/memory/hot-rules.md`
2. `.cursor/memory/active-context.md`
3. `.cursor/memory/memo.md`

SEARCH FIRST, THEN FETCH:
4. `.cursor/memory/lessons/index.md` -> find relevant lesson ID
5. `.cursor/memory/lessons/L-XXX-title.md` -> load ONLY the specific file
6. `.cursor/memory/digests/YYYY-MM.digest.md` -> before raw journal
7. `.cursor/memory/journal/YYYY-MM.md` -> only for archaeology

## Helper Scripts (macOS)

- Add lesson: `scripts/memory/add-lesson.sh --title "..." --tags "..." --rule "..."`
- Add journal: `scripts/memory/add-journal-entry.sh --tags "..." --title "..."`
- Rebuild: `scripts/memory/rebuild-memory-index.sh`
- Lint: `scripts/memory/lint-memory.sh`
- Query: `scripts/memory/query-memory.sh --query "..."`
- Clear: `scripts/memory/clear-active.sh`
EOF

# -------------------------
# Helper scripts (shell)
# -------------------------

write_file "$MEM_SCRIPTS_DIR/query-memory.sh" <<'EOF'
#!/bin/sh
set -eu

QUERY=""
AREA="all"

while [ $# -gt 0 ]; do
  case "$1" in
    --query) QUERY="$2"; shift 2;;
    --area) AREA="$2"; shift 2;;
    -h|--help)
      echo "Usage: sh ./scripts/memory/query-memory.sh --query \"...\" [--area all|hot|active|memo|lessons|journal|digests]"
      exit 0;;
    *) echo "Unknown arg: $1" >&2; exit 2;;
  esac
done

if [ -z "$QUERY" ]; then
  echo "Missing --query" >&2
  exit 2
fi

ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
MEM="$ROOT/.cursor/memory"

targets=""
case "$AREA" in
  hot) targets="$MEM/hot-rules.md" ;;
  active) targets="$MEM/active-context.md" ;;
  memo) targets="$MEM/memo.md" ;;
  lessons) targets="$MEM/lessons/index.md $MEM/lessons/L-*.md" ;;
  journal) targets="$MEM/journal-index.md $MEM/journal/*.md" ;;
  digests) targets="$MEM/digests/*.digest.md" ;;
  all) targets="$MEM/hot-rules.md $MEM/active-context.md $MEM/memo.md $MEM/lessons/index.md $MEM/digests/*.digest.md $MEM/journal/*.md" ;;
  *) echo "Unknown --area: $AREA" >&2; exit 2;;
esac

echo "Searching: $QUERY"
for t in $targets; do
  # shellcheck disable=SC2086
  [ -e $t ] || continue
  grep -nH "$QUERY" $t 2>/dev/null || true
done
EOF

write_file "$MEM_SCRIPTS_DIR/clear-active.sh" <<'EOF'
#!/bin/sh
set -eu
ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
ACTIVE="$ROOT/.cursor/memory/active-context.md"
cat > "$ACTIVE" <<'T'
# Active Context (Session Scratchpad)

Priority: this overrides older journal history *for this session only*.

CLEAR this file when the task is done:
- Run `scripts/memory/clear-active.sh`

## Current Goal
-

## Files in Focus
-

## Findings / Decisions
-

## Temporary Constraints
-

## Blockers
-
T
echo "Cleared: $ACTIVE"
EOF

write_file "$MEM_SCRIPTS_DIR/add-journal-entry.sh" <<'EOF'
#!/bin/sh
set -eu

TAGS=""
TITLE=""
FILES=""
WHY=""
DATE="$(date +%Y-%m-%d)"

while [ $# -gt 0 ]; do
  case "$1" in
    --tags) TAGS="$2"; shift 2;;
    --title) TITLE="$2"; shift 2;;
    --files) FILES="$2"; shift 2;;
    --why) WHY="$2"; shift 2;;
    --date) DATE="$2"; shift 2;;
    -h|--help)
      echo "Usage: sh ./scripts/memory/add-journal-entry.sh --tags \"UI,Fix\" --title \"...\" [--files \"a,b\"] [--why \"...\"] [--date YYYY-MM-DD]"
      exit 0;;
    *) echo "Unknown arg: $1" >&2; exit 2;;
  esac
done

if [ -z "$TAGS" ] || [ -z "$TITLE" ]; then
  echo "Missing --tags or --title" >&2
  exit 2
fi

ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
MEM="$ROOT/.cursor/memory"
JOURNAL_DIR="$MEM/journal"
MONTH="$(echo "$DATE" | cut -c1-7)"
JOURNAL="$JOURNAL_DIR/$MONTH.md"
PROJECT_NAME="$(basename "$ROOT")"

mkdir -p "$JOURNAL_DIR"

tag_string=""
oldIFS="$IFS"; IFS=','; set -- $TAGS; IFS="$oldIFS"
for t in "$@"; do
  tt="$(echo "$t" | awk '{$1=$1;print}')"
  [ -n "$tt" ] && tag_string="${tag_string}[$tt]"
done

entry="- $tag_string $TITLE"
if [ -n "$WHY" ]; then
  entry="${entry}\n  - Why: $WHY"
fi
if [ -n "$FILES" ]; then
  entry="${entry}\n  - Key files:"
  oldIFS="$IFS"; IFS=','; set -- $FILES; IFS="$oldIFS"
  for f in "$@"; do
    ff="$(echo "$f" | awk '{$1=$1;print}')"
    [ -n "$ff" ] && entry="${entry}\n    - \`$ff\`"
  done
fi

if [ ! -f "$JOURNAL" ]; then
  cat > "$JOURNAL" <<EOF2
# Development Journal - $PROJECT_NAME ($MONTH)

## $DATE

$(printf "%b" "$entry")
EOF2
  echo "Added journal entry to: $JOURNAL"
  exit 0
fi

if grep -q "^## $DATE\$" "$JOURNAL"; then
  awk -v d="$DATE" -v e="$(printf "%b" "$entry")" '
    BEGIN { in=0; done=0 }
    {
      print $0
      if ($0 == "## " d) { in=1; next }
      if (in==1 && done==0 && $0 ~ /^## [0-9]{4}-[0-9]{2}-[0-9]{2}$/) {
        print ""
        print e
        print ""
        done=1
        in=0
      }
    }
    END {
      if (done==0) {
        print ""
        print e
        print ""
      }
    }
  ' "$JOURNAL" > "$JOURNAL.tmp.$$"
  mv "$JOURNAL.tmp.$$" "$JOURNAL"
else
  {
    printf "\n## %s\n\n" "$DATE"
    printf "%b\n" "$entry"
  } >> "$JOURNAL"
fi

echo "Added journal entry to: $JOURNAL"
EOF

write_file "$MEM_SCRIPTS_DIR/add-lesson.sh" <<'EOF'
#!/bin/sh
set -eu

TITLE=""
TAGS=""
RULE=""
APPLIES_TO="*"

while [ $# -gt 0 ]; do
  case "$1" in
    --title) TITLE="$2"; shift 2;;
    --tags) TAGS="$2"; shift 2;;
    --rule) RULE="$2"; shift 2;;
    --applies-to) APPLIES_TO="$2"; shift 2;;
    -h|--help)
      echo "Usage: sh ./scripts/memory/add-lesson.sh --title \"...\" --tags \"Reliability,Data\" --rule \"...\" [--applies-to \"*\"]"
      exit 0;;
    *) echo "Unknown arg: $1" >&2; exit 2;;
  esac
done

if [ -z "$TITLE" ] || [ -z "$TAGS" ] || [ -z "$RULE" ]; then
  echo "Missing --title/--tags/--rule" >&2
  exit 2
fi

ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
LESSONS="$ROOT/.cursor/memory/lessons"
mkdir -p "$LESSONS"

max=0
for f in "$LESSONS"/L-*.md; do
  [ -e "$f" ] || continue
  b="$(basename "$f")"
  n="$(echo "$b" | sed -n 's/^L-\([0-9][0-9][0-9]\).*/\1/p')"
  [ -n "$n" ] && [ "$n" -gt "$max" ] && max="$n"
done

next=$((max + 1))
ID="$(printf "L-%03d" "$next")"

kebab="$(echo "$TITLE" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+//; s/-+$//;')"
[ -z "$kebab" ] && kebab="lesson"
file="$LESSONS/${ID}-${kebab}.md"

today="$(date +%Y-%m-%d)"
tags_list="$(echo "$TAGS" | sed 's/, */, /g')"

cat > "$file" <<EOF2
---
id: $ID
title: $TITLE
status: Active
tags: [$tags_list]
introduced: $today
applies_to:
  - $APPLIES_TO
triggers:
  - TODO: add error messages or keywords
rule: $RULE
---

# $ID - $TITLE

## Symptom

TODO

## Root Cause

TODO

## Wrong Approach (DO NOT REPEAT)

- TODO

## Correct Approach

- TODO
EOF2

echo "Created lesson: $file"
echo "Next: run scripts/memory/rebuild-memory-index.sh"
EOF

write_file "$MEM_SCRIPTS_DIR/rebuild-memory-index.sh" <<'EOF'
#!/bin/sh
set -eu

ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
MEM="$ROOT/.cursor/memory"
LESSONS="$MEM/lessons"
JOURNAL="$MEM/journal"
DIGESTS="$MEM/digests"

mkdir -p "$LESSONS" "$JOURNAL" "$DIGESTS"

gen="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

out="$LESSONS/index.md"
{
  echo "# Lessons Index (generated)"
  echo ""
  echo "Generated: $gen"
  echo ""
  echo "Format: ID | [Tags] | AppliesTo | Rule | File"
  echo ""
} > "$out"

count=0
for f in "$LESSONS"/L-*.md; do
  [ -e "$f" ] || continue
  id="$(awk 'NR==1 && $0=="---"{in=1;next} in && $0=="---"{exit} in && $1=="id:"{print $2; exit}' "$f" 2>/dev/null || true)"
  [ -z "$id" ] && continue
  title="$(awk 'NR==1 && $0=="---"{in=1;next} in && $0=="---"{exit} in && $1=="title:"{$1=""; sub(/^ /,""); print; exit}' "$f" 2>/dev/null || true)"
  rule="$(awk 'NR==1 && $0=="---"{in=1;next} in && $0=="---"{exit} in && $1=="rule:"{$1=""; sub(/^ /,""); print; exit}' "$f" 2>/dev/null || true)"
  tags="$(awk 'NR==1 && $0=="---"{in=1;next} in && $0=="---"{exit} in && $1=="tags:"{$1=""; sub(/^ /,""); print; exit}' "$f" 2>/dev/null || true)"
  applies="$(awk 'NR==1 && $0=="---"{in=1;next} in && $0=="---"{exit} in && $0=="applies_to:"{getline; sub(/^ *- */,""); print; exit}' "$f" 2>/dev/null || true)"
  [ -z "$applies" ] && applies="(any)"
  [ -z "$tags" ] && tags="[]"
  bn="$(basename "$f")"
  echo "$id | $tags | $applies | ${rule:-$title} | \`$bn\`" >> "$out"
  count=$((count + 1))
done

if [ "$count" -eq 0 ]; then
  echo "(No lessons yet.)" >> "$out"
fi

for jf in "$JOURNAL"/*.md; do
  [ -e "$jf" ] || continue
  base="$(basename "$jf")"
  case "$base" in
    README.md) continue ;;
  esac
  month="${base%.md}"
  digest="$DIGESTS/$month.digest.md"
  {
    echo "# Monthly Digest - $month (generated)"
    echo ""
    echo "Generated: $gen"
    echo ""
    echo "Token-cheap summary. See \`.cursor/memory/journal/$base\` for details."
    echo ""
  } > "$digest"

  awk '
    BEGIN { d="" }
    /^## [0-9]{4}-[0-9]{2}-[0-9]{2}$/ { d=$2; print "## " d "\n"; next }
    /^- / {
      if (d!="") print $0
      next
    }
  ' "$jf" >> "$digest"
done

echo "Rebuild complete."
EOF

write_file "$MEM_SCRIPTS_DIR/lint-memory.sh" <<'EOF'
#!/bin/sh
set -eu

ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
MEM="$ROOT/.cursor/memory"

hot="$MEM/hot-rules.md"
active="$MEM/active-context.md"
memo="$MEM/memo.md"

chars=0
for f in "$hot" "$active" "$memo"; do
  [ -f "$f" ] || continue
  c="$(wc -c < "$f" | awk '{$1=$1;print}')"
  chars=$((chars + c))
done

tokens=$((chars / 4))
echo "Always-read layer: ${chars} chars (~${tokens} tokens)"
if [ "$chars" -gt 8000 ]; then
  echo "ERROR: Always-read layer exceeds 8000 chars (~2000 tokens)" >&2
  exit 1
fi
echo "Lint passed"
EOF

# -------------------------
# Git hook (portable)
# -------------------------

write_file "$GITHOOKS_DIR/pre-commit" <<'EOF'
#!/bin/sh
set -e

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT"

echo "[Mnemo] Rebuilding indexes + lint..."
sh "./scripts/memory/rebuild-memory-index.sh"
sh "./scripts/memory/lint-memory.sh"

git add .cursor/memory/lessons/index.md 2>/dev/null || true
git add .cursor/memory/digests/*.digest.md 2>/dev/null || true
exit 0
EOF

chmod +x "$MEM_SCRIPTS_DIR/"*.sh "$GITHOOKS_DIR/pre-commit" 2>/dev/null || true

echo ""
echo "Setup complete (Mnemo macOS shell installer)."
echo "Next:"
echo "  sh ./scripts/memory/rebuild-memory-index.sh"
echo "  sh ./scripts/memory/lint-memory.sh"
echo "  git config core.hooksPath .githooks"

